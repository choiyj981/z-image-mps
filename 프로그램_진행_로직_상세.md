# 네이버 블로그 자동화 프로그램 진행 로직 상세

## 📋 전체 워크플로우 개요

```
[시작] → [1차 가공] → [2차 가공] → [3차 가공] → [이미지 생성] → [포스팅] → [완료]
```

---

## 🔵 Step 0: 1차 가공 (네이버 검색 및 초안 생성)

### API 엔드포인트
- `/api/workflow/step0` (1차 가공만 실행)
- `/api/workflow/execute` (전체 워크플로우)

### 입력 데이터
- `keyword`: 검색할 키워드 (필수)
- `headless`: 브라우저 헤드리스 모드 (기본값: True)
- `post_count`: 수집할 포스트 개수 (기본값: 3)

### 처리 과정

#### 1. 요청 검증
```
키워드 입력 확인
↓
Gemini API 키 확인 (config.json)
```

#### 2. 네이버 블로그 검색
```
NaverBlogContentGenerator 초기화
↓
Selenium WebDriver 실행 (headless 옵션)
↓
네이버 블로그 검색 페이지 접속
↓
키워드로 검색 실행
↓
상위 N개 포스트 URL 수집
```

#### 3. 콘텐츠 수집
```
각 포스트 URL 접속
↓
제목 추출
↓
본문 내용 추출
↓
수집된 데이터 정리
```

#### 4. AI 초안 생성
```
수집된 데이터를 Gemini API에 전달
↓
프롬프트: "다음 네이버 블로그 포스트들을 참고하여 
          새로운 블로그 포스트를 작성해주세요"
↓
제목 + 본문 초안 생성
```

#### 5. 결과 반환
```json
{
  "success": true,
  "title": "생성된 제목",
  "content": "생성된 본문",
  "length": 1234
}
```

### 에러 처리
- 키워드 없음 → 에러 반환
- API 키 없음 → 에러 반환
- 검색 실패 → 에러 반환
- 드라이버 종료 (finally 블록)

---

## 🟢 Step 1: 2차 가공 (템플릿 적용 및 텍스트 가공)

### API 엔드포인트
- `/api/step1`

### 입력 데이터
- `title`: 1차 가공에서 생성된 제목
- `content`: 1차 가공에서 생성된 본문
- `template_id`: 사용할 템플릿 ID (기본값: 'default')

### 처리 과정

#### 1. API 키 확인
```
Gemini 또는 Claude API 키 확인
↓
모델 초기화
```

#### 2. 템플릿 로드
```
template_manager.get_template(template_id)
↓
템플릿이 없으면 기본 템플릿 사용
↓
템플릿 구성 요소 확인:
  - headings (제목)
  - paragraphs (문단)
  - tip_box (팁 박스)
  - info_box (정보 박스)
  - warning_box (경고 박스)
  - checklist_box (체크리스트)
  - tables (표)
  - 등등...
```

#### 3. 프롬프트 템플릿 로드
```
configs/prompt_templates/prompt_template.txt 파일 읽기
↓
템플릿 설정에 따라 프롬프트 생성
↓
template_manager.generate_step1_prompt() 호출
```

#### 4. AI 텍스트 가공
```
생성된 프롬프트를 API에 전달
↓
Gemini 또는 Claude API 호출
↓
가공된 텍스트 수신
```

#### 5. 결과 반환
```json
{
  "success": true,
  "content": "가공된 텍스트 (마크다운 형식)",
  "length": 2345
}
```

### 특징
- 템플릿에 따라 다양한 박스, 리스트, 표 등이 자동 생성됨
- 이미지 플레이스홀더 `[이미지: 설명]` 형식으로 삽입됨

---

## 🟡 Step 2: 3차 가공 (HTML 변환)

### API 엔드포인트
- `/api/step2`

### 입력 데이터
- `title`: 제목
- `content`: 2차 가공 결과 (마크다운 텍스트)
- `template_id`: 템플릿 ID
- `image_api`: 이미지 생성 API 선택 ('gemini' 또는 'pollinations')

### 처리 과정

#### 1. 텍스트 구조 분석
```
NaverHTMLTemplates.analyze_text_structure() 호출
↓
세그먼트 분석:
  - 제목 (heading) 개수
  - 리스트 (list) 개수
  - 표 (table) 개수
  - 박스 (box) 개수
  - 이미지 플레이스홀더 개수
  - 숫자 데이터 포함 여부
↓
분석 결과 요약 생성
```

#### 2. 템플릿 및 프롬프트 준비
```
템플릿 로드 (template_id)
↓
HTML 변환 프롬프트 템플릿 로드
  (configs/prompt_templates/html_conversion_template.txt)
↓
템플릿 설정에 따라 프롬프트 생성
↓
분석 결과를 프롬프트에 추가
↓
{title}, {content} 치환
```

#### 3. AI HTML 생성
```
Gemini 또는 Claude API 호출
↓
HTML 코드 생성
↓
응답에서 HTML 코드 추출
  (코드 블록 또는 <div> 태그 찾기)
```

#### 4. HTML 후처리
```
HTML 래퍼 추가 (없으면)
↓
날짜 정보 제거 (날짜: 2025-12-01 형식)
↓
이모티콘 제거 (본문 텍스트만, 디자인 요소는 유지)
  - 💡 TIP, ⚠️ 경고 등은 유지
  - 일반 텍스트의 이모티콘만 제거
```

#### 5. 이미지 플레이스홀더 추출
```
2차 가공 결과에서 [이미지: 설명] 형식 추출
↓
HTML에서 <span class="se-image-placeholder"> 추출
↓
플레이스홀더 정보 정리
```

#### 6. 결과 반환
```json
{
  "success": true,
  "html": "미리보기용 HTML (이미지 태그 포함)",
  "original_html": "포스팅용 HTML (플레이스홀더 유지)",
  "length": 3456,
  "image_count": 5,
  "logs": ["[3차 가공] 시작...", ...],
  "analysis": {
    "segments": 15,
    "headings": 4,
    "lists": 3,
    "tables": 1,
    "boxes": 5
  }
}
```

---

## 🖼️ 이미지 생성 및 삽입

### 처리 시점
- 3차 가공 (Step 2) 중에 자동 실행

### 처리 과정

#### 1. 이미지 설명 수집
```
원본 설명 우선 사용:
  - 2차 가공 결과의 [이미지: 설명] 형식
  - 없으면 HTML 플레이스홀더의 alt 텍스트
  - 둘 다 없으면 "이미지 N" 기본값
```

#### 2. 프롬프트 변환
```
각 이미지 설명에 대해:
  ↓
Gemini API로 한국어 → 영어 프롬프트 변환
  프롬프트: "다음 한국어 이미지 설명을 영어 이미지 생성 
            프롬프트로 정확히 변환해주세요"
  ↓
영어 프롬프트 정제 (불필요한 설명 제거)
  ↓
photorealistic, high quality 스타일 추가
```

#### 3. 이미지 생성
```
선택된 API에 따라 생성:

[Gemini API 선택 시]
  - generate_image_with_gemini() 호출
  - Gemini 이미지 생성 API 사용
  - 바나나 API 키 사용

[Pollinations AI 선택 시]
  - generate_image_with_pollinations() 호출
  - Pollinations AI API 사용
  ↓
이미지 파일 저장 (content/images/image_N_timestamp.png)
```

#### 4. 이미지 삽입
```
생성된 이미지와 플레이스홀더 매칭
↓
네이버 블로그 플레이스홀더 생성:
  <span class="se-image-placeholder" 
        data-path="content/images/filename.png" 
        data-alt="설명">
↓
HTML의 플레이스홀더 위치에 삽입
  (역순으로 교체하여 인덱스 유지)
```

#### 5. 결과
- 미리보기용: 실제 `<img>` 태그로 변환
- 포스팅용: 네이버 플레이스홀더 유지

---

## 📤 포스팅 (네이버 블로그 발행)

### API 엔드포인트
- `/api/post`

### 입력 데이터
- `title`: 제목
- `html`: HTML 내용 (플레이스홀더 포함)

### 처리 과정

#### 1. 계정 정보 로드
```
config.json에서 네이버 계정 정보 로드
  또는 AccountManager에서 계정 정보 가져오기
↓
ExcelBasedBlogAutomation 인스턴스 생성
↓
naver_id, naver_password 설정
```

#### 2. 브라우저 설정
```
Selenium WebDriver 초기화
↓
setup_driver() 호출
↓
Chrome 브라우저 실행
```

#### 3. 네이버 로그인
```
네이버 로그인 페이지 접속
↓
ID, 비밀번호 입력
↓
로그인 버튼 클릭
↓
로그인 성공 확인
```

#### 4. 이미지 매칭
```
HTML에서 플레이스홀더 추출
↓
각 플레이스홀더에 대해:
  - data-path에서 파일명 추출
  - content/images/ 폴더에서 실제 파일 찾기
  - 파일이 없으면 사용 가능한 이미지 중 선택
↓
html_matched_images 리스트 생성
```

#### 5. 포스팅 실행
```
write_single_blog_post_with_publish_html() 호출
↓
블로그 글쓰기 페이지 접속
↓
제목 입력
↓
HTML 내용 붙여넣기
↓
이미지 삽입:
  - 각 플레이스홀더 위치에서
  - 클립보드에 이미지 복사
  - Ctrl+V로 이미지 삽입
↓
발행 버튼 클릭 (즉시발행)
↓
포스팅 완료 확인
```

#### 6. 결과 반환
```json
{
  "success": true,
  "message": "네이버 블로그 포스팅 완료!",
  "logs": "전체 로그 내용..."
}
```

### 에러 처리
- 드라이버 설정 실패 → 에러 반환
- 로그인 실패 → 브라우저 종료 후 에러 반환
- 포스팅 실패 → 로그에서 에러 메시지 추출
- 성공 시 → 브라우저 유지 (사용자 확인용)

---

## 🔄 전체 워크플로우 실행

### API 엔드포인트
- `/api/workflow/execute`

### 입력 데이터
- `keyword`: 검색 키워드
- `account_id`: 계정 ID (선택)
- `headless`: 헤드리스 모드
- `image_api`: 이미지 생성 API 선택

### 실행 순서
```
1. Step 0 실행 (1차 가공)
   ↓
2. Step 1 실행 (2차 가공)
   ↓
3. Step 2 실행 (3차 가공 + 이미지 생성)
   ↓
4. 포스팅 실행
   ↓
5. 완료
```

### 각 단계별 에러 처리
- 각 단계에서 실패 시 해당 단계 정보와 함께 에러 반환
- `step` 필드에 실패한 단계 표시
- `traceback` 필드에 상세 에러 정보 포함

---

## 📊 주요 컴포넌트

### 1. NaverBlogContentGenerator
- 네이버 블로그 검색 및 콘텐츠 수집
- Selenium WebDriver 사용

### 2. TemplateManager
- 템플릿 관리 및 프롬프트 생성
- 템플릿 설정에 따른 동적 프롬프트 생성

### 3. NaverHTMLTemplates
- 텍스트 구조 분석
- HTML 변환 및 플레이스홀더 처리
- 네이버 블로그 플레이스홀더 생성

### 4. ParagraphImageGenerator
- 이미지 프롬프트 변환
- 이미지 생성 (Gemini/Pollinations)
- 이미지 파일 저장

### 5. ExcelBasedBlogAutomation
- 네이버 블로그 자동화
- 로그인 및 포스팅
- 이미지 삽입

---

## 🎯 주요 특징

### 1. 단계별 실행 가능
- 각 단계를 독립적으로 실행 가능
- 중간 결과 확인 및 수정 가능

### 2. 템플릿 시스템
- 다양한 템플릿 지원
- 템플릿별 다른 스타일 적용

### 3. 이미지 자동 생성
- AI 기반 이미지 생성
- 한국어 설명 자동 번역
- 네이버 블로그 형식에 맞게 삽입

### 4. 에러 처리
- 각 단계별 상세한 에러 메시지
- 로그 수집 및 반환
- 브라우저 자동 정리

### 5. 미리보기 기능
- `/api/preview` 엔드포인트
- HTML 미리보기 생성
- 이미지 플레이스홀더를 실제 이미지로 변환

---

## 📝 로그 시스템

### 로그 수집
- 각 단계별 상세 로그 수집
- `process_logs` 리스트에 저장
- API 응답에 포함

### 로그 예시
```
[3차 가공] 시작...
[3차 가공] 제목: 미국 셧다운...
[3차 가공] 텍스트 구조 분석 시작...
[3차 가공] 텍스트 구조 분석 완료: 15개 세그먼트 발견
[이미지 생성] 이미지 생성 시작...
[이미지 생성] (1/5) 원본 설명 사용: 의사당 앞에서...
[이미지 생성] ✅ 이미지 생성 완료: image_1_1764647960.png
[이미지 삽입] ✅ 5개 이미지 삽입 완료
```

---

## 🔧 설정 파일

### config.json
```json
{
  "gemini_api_key": "API 키",
  "claude_api_key": "API 키",
  "naver_id": "네이버 ID",
  "naver_password": "네이버 비밀번호"
}
```

### 템플릿 파일
- `configs/prompt_templates/prompt_template.txt` (2차 가공용)
- `configs/prompt_templates/html_conversion_template.txt` (3차 가공용)

---

## 🚀 실행 방법

### 1. 웹 GUI 실행
```bash
python web_gui_step2.py
```
- 브라우저에서 `http://localhost:8080` 접속

### 2. API 직접 호출
```python
# 1차 가공만
POST /api/workflow/step0
{
  "keyword": "검색 키워드",
  "headless": true
}

# 전체 워크플로우
POST /api/workflow/execute
{
  "keyword": "검색 키워드",
  "headless": true,
  "image_api": "pollinations"
}
```

---

## 📌 주의사항

1. **API 키 필수**: Gemini 또는 Claude API 키가 필요합니다
2. **네이버 계정**: 포스팅을 위해서는 네이버 계정 정보가 필요합니다
3. **이미지 생성 시간**: 이미지 생성은 시간이 걸릴 수 있습니다
4. **브라우저**: Selenium을 사용하므로 Chrome 브라우저가 필요합니다
5. **에러 처리**: 각 단계에서 실패 시 상세한 에러 메시지를 확인하세요

---

## 🎨 템플릿 구성 요소

### 지원되는 컴포넌트
- ✅ 제목 (headings)
- ✅ 문단 (paragraphs)
- ✅ 팁 박스 (tip_box)
- ✅ 정보 박스 (info_box)
- ✅ 경고 박스 (warning_box)
- ✅ 위험 박스 (danger_box)
- ✅ 성공 박스 (success_box)
- ✅ 체크리스트 박스 (checklist_box)
- ✅ 단계 가이드 박스 (step_guide_box)
- ✅ 표 (tables)
- ✅ 인용문 (quotation)
- ✅ 스티커 (stickers)
- ✅ 버튼 (buttons)

각 템플릿은 이러한 컴포넌트의 조합으로 구성됩니다.



